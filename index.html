<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>VR-Goal</title>
<style>
  body{margin:0;background:#111;color:#fff;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;}
  .wrap{max-width:980px;margin:0 auto;padding:16px;}
  .card{background:#151515;border:1px solid #262626;border-radius:16px;padding:14px;}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  label{display:flex;gap:8px;align-items:center;font-size:13px;opacity:.92}
  input{font-size:14px;padding:10px 12px;border-radius:12px;border:1px solid #2a2a2a;background:#101010;color:#fff;min-width:180px}
  button{font-size:14px;padding:10px 12px;border-radius:12px;border:1px solid #2a2a2a;background:#101010;color:#fff;cursor:pointer}
  button.primary{background:#1b1b1b;border-color:#3a3a3a}
  .hint{font-size:12px;opacity:.7;line-height:1.45;margin-top:10px}
  canvas{display:block;width:100%;height:auto;border-radius:16px;background:#111;margin-top:12px}
  .topbar{display:flex;justify-content:space-between;align-items:center;margin-bottom:10px}
  .pill{font-size:12px;opacity:.8;border:1px solid #2a2a2a;padding:6px 10px;border-radius:999px}
  .hidden{display:none}
</style>
</head>
<body>
<div class="wrap">

  <!-- 결과 화면(기본) -->
  <div id="viewPage">
    <div class="topbar">
      <div class="pill" id="metaText">1179×2556</div>
      <div class="row">
        <button id="saveBtn" class="primary">PNG 저장</button>
        <button id="goSettingsBtn">설정</button>
      </div>
    </div>
    <canvas id="c" width="1179" height="2556"></canvas>
    <div class="hint">
      기본은 결과만 표시. 설정은 <b>#settings</b> (예: <b>https://vr-goal.vercel.app/#settings</b>)
    </div>
  </div>

  <!-- 숨겨진 세팅 페이지 -->
  <div id="settingsPage" class="hidden">
    <div class="card">
      <div class="topbar">
        <div class="pill">Settings (Hidden)</div>
        <button id="backBtn">결과로</button>
      </div>

      <div class="row">
        <label>Start <input id="start" type="date"></label>
        <label>Goal <input id="goal" type="date"></label>
        <label>Title <input id="title" type="text" maxlength="30"></label>
      </div>

      <div class="row" style="margin-top:10px">
        <button id="saveSettingsBtn" class="primary">저장</button>
        <button id="resetBtn">초기화</button>
      </div>

      <div class="hint">
        저장하면 이 브라우저에 유지됨(localStorage).<br/>
        숨김 접속: <b>https://vr-goal.vercel.app/#settings</b>
      </div>
    </div>
  </div>

</div>

<script>
(() => {
  /* =========================
     0) 기본 설정(초기값)
     ========================= */
  const DEFAULTS = {
    start: "2021-12-05",
    goal:  "2031-12-05",
    title: "V.R. 10Y"
  };

  const STORAGE_KEY = "vr_goal_settings_v2";

  /* =========================
     1) 페이지 전환(숨김 세팅)
     ========================= */
  const viewPage = document.getElementById("viewPage");
  const settingsPage = document.getElementById("settingsPage");

  function showView(){
    viewPage.classList.remove("hidden");
    settingsPage.classList.add("hidden");
    if (location.hash !== "") history.replaceState(null, "", location.pathname);
  }

  function showSettings(){
    viewPage.classList.add("hidden");
    settingsPage.classList.remove("hidden");
    if (location.hash !== "#settings") location.hash = "#settings";
  }

  document.getElementById("goSettingsBtn").addEventListener("click", showSettings);
  document.getElementById("backBtn").addEventListener("click", () => { showView(); render(); });

  window.addEventListener("hashchange", () => {
    if (location.hash === "#settings") showSettings();
    else { showView(); render(); }
  });

  /* =========================
     2) 설정 로드/저장
     ========================= */
  const elStart = document.getElementById("start");
  const elGoal  = document.getElementById("goal");
  const elTitle = document.getElementById("title");

  function loadSettings(){
    try{
      const raw = localStorage.getItem(STORAGE_KEY);
      if(!raw) return {...DEFAULTS};
      const s = JSON.parse(raw);
      return {
        start: s.start || DEFAULTS.start,
        goal:  s.goal  || DEFAULTS.goal,
        title: (s.title || DEFAULTS.title).slice(0,30)
      };
    }catch(_){
      return {...DEFAULTS};
    }
  }

  function saveSettings(s){
    localStorage.setItem(STORAGE_KEY, JSON.stringify(s));
  }

  function applySettingsToInputs(s){
    elStart.value = s.start;
    elGoal.value  = s.goal;
    elTitle.value = s.title;
  }

  function readInputs(){
    return {
      start: elStart.value || DEFAULTS.start,
      goal:  elGoal.value  || DEFAULTS.goal,
      title: (elTitle.value || DEFAULTS.title).trim().slice(0,30) || DEFAULTS.title
    };
  }

  document.getElementById("saveSettingsBtn").addEventListener("click", () => {
    const s = readInputs();
    if (s.goal < s.start){
      const tmp = s.start; s.start = s.goal; s.goal = tmp;
      applySettingsToInputs(s);
    }
    saveSettings(s);
    showView();
    render();
  });

  document.getElementById("resetBtn").addEventListener("click", () => {
    saveSettings({...DEFAULTS});
    applySettingsToInputs({...DEFAULTS});
  });

  /* =========================
     3) 월페이퍼 렌더링(캔버스)
     ========================= */
  const W = 1179, H = 2556;
  const c = document.getElementById("c");
  const ctx = c.getContext("2d");

  // 시안 느낌에 맞춘 톤(흰색/회색/오렌지)
  const BG = "#121212";
  const DOT_FUTURE = "rgba(255,255,255,0.14)";
  const DOT_DONE   = "rgba(255,255,255,0.92)";
  const DOT_BLANK  = "rgba(255,255,255,0.08)";
  const ACCENT     = "#ff6a2a"; // 시안의 주황 톤에 가까운 편
  const LABEL      = "rgba(255,255,255,0.45)";
  const YEAR_TEXT  = "rgba(255,255,255,0.92)";
  const LINE_PAST  = "rgba(255,255,255,0.90)";
  const LINE_FUT   = "rgba(255,255,255,0.22)";

  // “가운데 몰림” 레이아웃 폭(아이폰 배경에서 좌우 여백 넉넉하게)
  const COLUMN_W = Math.round(W * 0.74);
  const COLUMN_X = Math.round((W - COLUMN_W) / 2);

  // 상/하단 여백(아이폰 시간/위젯, 홈바 영역 확보)
  const SAFE_TOP = Math.round(H * 0.16);
  const SAFE_BOT = Math.round(H * 0.18);

  function clamp(n,a,b){ return Math.max(a, Math.min(b,n)); }

  function parseDate(v){
    const [y,m,d] = v.split("-").map(Number);
    return new Date(y, m-1, d);
  }

  function daysBetween(a,b){
    const A = new Date(a.getFullYear(), a.getMonth(), a.getDate());
    const B = new Date(b.getFullYear(), b.getMonth(), b.getDate());
    return Math.floor((B - A) / 86400000);
  }

  function sameDay(a,b){
    return a.getFullYear()===b.getFullYear() && a.getMonth()===b.getMonth() && a.getDate()===b.getDate();
  }

  function clear(){
    ctx.fillStyle = BG;
    ctx.fillRect(0,0,W,H);
  }

  function drawRoundLine(x0,y0,x1,y1,w,color){
    ctx.save();
    ctx.strokeStyle = color;
    ctx.lineWidth = w;
    ctx.lineCap = "round";
    ctx.beginPath();
    ctx.moveTo(x0,y0);
    ctx.lineTo(x1,y1);
    ctx.stroke();
    ctx.restore();
  }

  /* ===== 핵심: 연도 진행을 “위/아래 라인 스택”으로 =====
     - 지난 연도: 위 스택에 흰 줄
     - 남은 연도: 아래 스택에 회색 줄
     - 현재 연도는 줄에서 제외하고, 가운데에 큰 숫자로 표시
  */
  function drawYearStacks(start, goal, today){
    const y0 = start.getFullYear();
    const y1 = goal.getFullYear();

    const currentYear = today.getFullYear();
    const years = [];
    for(let y=y0; y<=y1; y++) years.push(y);

    const pastYears = years.filter(y => y < currentYear);
    const futureYears = years.filter(y => y > currentYear);

    // 시안처럼 여러 줄(연도 수만큼) 쌓되, 너무 많으면 “표시 줄 수”를 줄여도 됨.
    // 일단은 10~11년 수준이면 그대로 쌓아도 시각적으로 괜찮음.
    const lineH = 6;        // 줄 두께
    const lineGap = 18;     // 줄 간격(시안 느낌)
    const lineLen = Math.round(COLUMN_W * 0.92);
    const x0Line = Math.round(COLUMN_X + (COLUMN_W - lineLen)/2);
    const x1Line = x0Line + lineLen;

    // 위 스택(지난 연도)
    const topBlockY = SAFE_TOP + 120;
    for(let i=0;i<pastYears.length;i++){
      const y = topBlockY + i*lineGap;
      drawRoundLine(x0Line, y, x1Line, y, lineH, LINE_PAST);
    }

    // 가운데 연도 텍스트 (위 스택과 아래 스택 사이)
    const yearTextY = topBlockY + pastYears.length*lineGap + 170;
    ctx.save();
    ctx.textAlign = "center";
    ctx.fillStyle = YEAR_TEXT;
    ctx.font = "700 78px Georgia, 'Times New Roman', serif"; // 시안의 느낌(세리프)
    ctx.fillText(String(currentYear), W/2, yearTextY);
    ctx.restore();

    // 아래 스택(남은 연도)
    const bottomBlockY = yearTextY - 6 + 140; // 연도 텍스트 아래 시작점
    for(let i=0;i<futureYears.length;i++){
      const y = bottomBlockY + i*lineGap;
      drawRoundLine(x0Line, y, x1Line, y, lineH, LINE_FUT);
    }

    // 다음 요소(달력)의 시작 y를 리턴
    return bottomBlockY + futureYears.length*lineGap + 40;
  }

  function drawMonths(currentYear, start, goal, today, topY){
    // 3x4 월 그리드: “가운데 몰림” + 좌우 여백
    const gridX = COLUMN_X;
    const gridW = COLUMN_W;
    const cols = 3, rows = 4;

    const cellGapX = 50;
    const cellGapY = 44;

    const cellW = Math.floor((gridW - cellGapX*(cols-1))/cols);
    const cellH = 230; // 시안처럼 도트만 보이게 깔끔하게(카드 배경 제거)

    const names = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];

    ctx.save();
    for(let m=0;m<12;m++){
      const cx = m % cols;
      const cy = Math.floor(m / cols);

      const x = gridX + cx*(cellW + cellGapX);
      const y = topY + cy*(cellH + cellGapY);

      // 월 라벨
      ctx.fillStyle = LABEL;
      ctx.font = "600 22px system-ui,-apple-system,Segoe UI,Roboto,sans-serif";
      ctx.textAlign = "left";
      ctx.fillText(names[m], x, y);

      // 도트 영역
      const dotsX = x;
      const dotsY = y + 28;
      const dotsW = cellW;
      const dotCols = 7;      // 달력 느낌(7열)
      const gap = 10;

      // 도트 크기(원형)
      const dotSize = Math.floor((dotsW - gap*(dotCols-1))/dotCols);
      const r = dotSize/2;

      const daysInMonth = new Date(currentYear, m+1, 0).getDate();
      const firstDay = new Date(currentYear, m, 1).getDay(); // 0=Sun
      const used = 42; // 6주 고정(시안처럼 깔끔한 덩어리)

      for(let i=0;i<used;i++){
        const rx = i % dotCols;
        const ry = Math.floor(i / dotCols);

        const px = dotsX + rx*(dotSize+gap) + r;
        const py = dotsY + ry*(dotSize+gap) + r;

        const dayNum = i - firstDay + 1;
        let fill = DOT_BLANK;

        if(dayNum >= 1 && dayNum <= daysInMonth){
          const date = new Date(currentYear, m, dayNum);

          // 프로젝트 범위 밖은 더 어둡게(원하면 유지)
          const outOfRange = (date < start || date > goal);

          if(date < today) fill = outOfRange ? "rgba(255,255,255,0.10)" : DOT_DONE;
          if(sameDay(date, today)) fill = ACCENT;
          if(date > today) fill = outOfRange ? "rgba(255,255,255,0.10)" : DOT_FUTURE;
        }

        ctx.fillStyle = fill;
        ctx.beginPath();
        ctx.arc(px, py, r, 0, Math.PI*2);
        ctx.fill();
      }
    }
    ctx.restore();

    // 그리드 끝 y 리턴
    const totalH = rows*cellH + (rows-1)*cellGapY + 28 + 6*(dotSize+gap); // 대략
    return topY + totalH;
  }

  function drawFooter(leftDays, pct){
    // 시안처럼 하단 중앙: "313d left · 14%" (left만 주황)
    const y = H - SAFE_BOT + 80;

    ctx.save();
    ctx.textAlign = "center";
    ctx.font = "600 30px system-ui,-apple-system,Segoe UI,Roboto,sans-serif";

    const leftText = `${leftDays}d left`;
    const pctText = `${pct}%`;
    const midDot = " · ";

    // 텍스트 폭을 계산해서 정확히 가운데 정렬(색 분리)
    const wLeft = ctx.measureText(leftText).width;
    const wDot  = ctx.measureText(midDot).width;
    const wPct  = ctx.measureText(pctText).width;
    const total = wLeft + wDot + wPct;

    const x0 = W/2 - total/2;

    ctx.fillStyle = ACCENT;
    ctx.fillText(leftText, x0 + wLeft/2, y);

    ctx.fillStyle = "rgba(255,255,255,0.45)";
    ctx.fillText(midDot, x0 + wLeft + wDot/2, y);

    ctx.fillStyle = "rgba(255,255,255,0.45)";
    ctx.fillText(pctText, x0 + wLeft + wDot + wPct/2, y);

    ctx.restore();
  }

  function render(){
    const s = loadSettings();
    let start = parseDate(s.start);
    let goal  = parseDate(s.goal);
    const title = s.title || DEFAULTS.title;
    const today = new Date();

    if(goal < start){ const t=start; start=goal; goal=t; }

    const total = Math.max(1, daysBetween(start, goal));
    const done  = clamp(daysBetween(start, today), 0, total);
    const pct = Math.floor((done/total)*100);
    const leftDays = Math.max(0, daysBetween(today, goal));

    document.getElementById("metaText").textContent = `1179×2556 · ${leftDays}d left · ${pct}%`;

    clear();

    // (선택) 타이틀을 화면에 안 넣고 싶으면 여기 2줄 삭제
    // 시안은 연도만 크게 있으니, title은 숨기고 싶으면 주석 처리하면 됨.
    // ctx.save(); ctx.fillStyle="rgba(255,255,255,0.0)"; ctx.restore();

    const nextY = drawYearStacks(start, goal, today);
    drawMonths(today.getFullYear(), start, goal, today, nextY + 20);
    drawFooter(leftDays, pct);
  }

  function scheduleNextMidnightRefresh(){
    const now = new Date();
    const next = new Date(now.getFullYear(), now.getMonth(), now.getDate()+1, 0, 0, 2);
    setTimeout(() => {
      render();
      scheduleNextMidnightRefresh();
    }, next - now);
  }

  /* =========================
     4) PNG 저장
     ========================= */
  document.getElementById("saveBtn").addEventListener("click", () => {
    const a = document.createElement("a");
    a.download = "vr-goal.png";
    a.href = c.toDataURL("image/png");
    a.click();
  });

  /* =========================
     5) 초기화
     ========================= */
  const settings = loadSettings();
  applySettingsToInputs(settings);

  if (location.hash === "#settings") showSettings();
  else showView();

  render();
  scheduleNextMidnightRefresh();
})();
</script>
</body>
</html>
